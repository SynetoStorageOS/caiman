#!/bin/sh
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
# Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.

. /lib/svc/share/smf_include.sh
. /usr/lib/installadm/installadm-common

# Make sure working directory is / to prevent unmounting problems.
cd /

# Apache configuration files
AI_HTTPD_CONF=/var/installadm/ai-webserver/ai-httpd.conf
LISTEN_ADDRESSES=/var/installadm/ai-webserver/listen-addresses.conf
COMPATIBILITY_PORTS=/var/installadm/ai-webserver/compatibility-configuration/ports.conf

# required commands
AIMDNSD=/usr/lib/installadm/aimdnsd.py
AIMDNSD_PID=/var/run/aimdnsd
APACHE2=/usr/apache2/2.2/bin/apachectl
AWK=/usr/bin/awk
CAT=/usr/bin/cat
CUT=/usr/bin/cut
CP=/usr/bin/cp
RM=/usr/bin/rm
DIFF=/usr/bin/diff
GREP=/bin/grep
KILL=/usr/bin/kill
HTTPD=/usr/apache2/2.2/bin/httpd
INSTALLADM=/usr/sbin/installadm
PS=/usr/bin/ps
PGREP=/usr/bin/pgrep
RM=/usr/bin/rm
SVCCFG=/usr/sbin/svccfg
SVCPROP=/usr/bin/svcprop

# Automated Install SMF variables
PORT='all_services/port'

# Global SMF property values
SMF_PORT=$($SVCPROP -p $PORT $SMF_FMRI 2>/dev/null)

#
# setup_compatibility_file
#	Sets up the compatibility file with the additional ports needed for
#	older services.  The ${AI_HTTPD_CONF} file contains a line that includes
#	the ${COMPATIBILITY_PORTS} file which this function creates.
#
#	Args
#		None
#	Globals
#		COMPATIBILITY_PORTS - Location of the file to set up.
#	Returns
#		0 - New ${COMPATIBILITY_PORTS} file has been put into place.
#		1 - Existing ${COMPATIBILITY_PORTS} file was not touched.
#
function setup_compatibility_file
{
	typeset work_file="/system/volatile/$(basename ${COMPATIBILITY_PORTS}).$$"

	${CAT} <<- COMPAT_EOF > ${work_file}
	#
	# Do not edit by hand.
	# This file is created by the svc:/system/install/server method script
	# and is Included in the AI webserver configuration file.
	#
	COMPAT_EOF

	# Get the list of unique and sorted IP addresses of the
	# network interfaces on this system that AI has been
	# configured to use.
	ips=$(valid_networks true)

	# add the necessary ports from the old services
	SMF_PGS=$(${SVCCFG} -s ${SMF_FMRI} listpg | ${AWK} '{print $1}' | \
		  ${GREP} "^AI")
	for pg in ${SMF_PGS} ; do
		status=$(${SVCPROP} -p ${pg}/status ${SMF_FMRI})
		if [ "X${status}" != "X" -a "${status}" == "on" ] ; then
			port=$(${SVCPROP} -cp ${pg}/txt_record ${SMF_FMRI} 2>/dev/null | \
				   ${CUT} -f 2 -s -d':')
			if [ "X${port}" != "X" -a  "${port}" != "${SMF_PORT}" ]; then
				for ip in ${ips} ; do
					echo "Listen" ${ip}:${port} >> ${work_file}
				done
			elif [ "X${port}" == "X" ]; then
				service=$(echo ${pg} | ${CUT} -c3-)
				echo "The port is not set in the txt_record for ${service}"
				exit $SMF_EXIT_ERR_CONFIG
			fi
		fi
	done

	# If the file exists and is identical to the new file,
	# no need to touch the existing file.
        if [[ -f ${COMPATIBILITY_PORTS} ]] ; then
		if $DIFF ${COMPATIBILITY_PORTS} ${work_file} \
		    > /dev/null 2>&1 ; then
			${RM} ${work_file}
			return 1
		fi
	fi

        ${CP} ${work_file} ${COMPATIBILITY_PORTS}
        ${RM} ${work_file}

        return 0
}

#
# setup_main_ports
#	Sets up the listen_address file with the ip addresses and SMF port
#	needed for the services.  The ${AI_HTTPD_CONF} file contains a line
#	that includes the ${LISTEN_ADDRESSES} file which this function creates.
#
#	Args
#		None
#	Globals
#		LISTEN_ADDRESSES - Location of the file to set up.
#	Returns
#		0 - New ${LISTEN_ADDRESSES} file has been put into place.
#               1 - Existing ${LISTEN_ADDRESSES} file was not touched.
#
function setup_main_ports
{
	typeset work_file="/system/volatile/$(basename ${LISTEN_ADDRESSES}).$$"

	${CAT} <<- LISTEN_EOF > ${work_file}
	#
	# Do not edit by hand.
	# This file is created by the svc:/system/install/server method script
	# and is Included in the AI webserver configuration file.
	#
	LISTEN_EOF

	# Get the list of unique and sorted IP addresses of the
	# network interfaces on this system that AI has been
	# configured to used.
	for ip in $(valid_networks true) ;
	do
		echo "Listen\t${ip}:${SMF_PORT}" >> ${work_file}
	done

	# If the file exists and is identical to the new file,
	# no need to touch the existing file.
	if [[ -f ${LISTEN_ADDRESSES} ]] ; then
		if $DIFF ${LISTEN_ADDRESSES} ${work_file} > /dev/null 2>&1; then
			${RM} ${work_file}
			return 1
		fi
	fi

	${CP} ${work_file} ${LISTEN_ADDRESSES}
	${RM} ${work_file}

	return 0
}

#
# upgrade_svc_vers_0_to_1
#	Re-registers any existing default manifests managed in the old style
#	to be handled the new way.
#
#	Args:
#		None
#
function upgrade_svc_vers_0_to_1
{
	AI_SERVICE_VERSION=1
	do_refresh=n
	SMF_PGS=$(${SVCCFG} -s ${SMF_FMRI} listpg | ${AWK} '{print $1}' | \
	    ${GREP} "^AI")
	for service in ${SMF_PGS} ; do

		# Version 0 may not have "version" property.
		version=$(${SVCPROP} -cp ${service}/version ${SMF_FMRI} \
		    2>/dev/null)
		if [ $? -eq 0 -a \
		    "${version}" -ge "${AI_SERVICE_VERSION}" ]; then
			continue
		fi
                errors=n

		service_name=$(${SVCPROP} -cp \
		    ${service}/service_name ${SMF_FMRI})
		if [[ $? -ne 0 ]]; then
			echo "Error getting service_name property " \
			    "from ${service}"
			continue
		fi

		do_refresh=y
		echo "Upgrading service ${service_name} to " \
		    "version ${AI_SERVICE_VERSION}"

		# See if default-manifest property exists for this AI service.
		${SVCPROP} -q -p ${service}/default-manifest ${SMF_FMRI}
		if [[ $? -ne 0 ]]; then
			echo "default-manifest property doesn't exist..."
	
			mfest_dir=/var/ai/${service_name}/AI_data
			echo "Checking whether manifest directory " \
			    "$mfest_dir exists..."
			if [ ! -d $mfest_dir ]; then
				echo "No... Checking port compatibility " \
				    "directory instead..."
				port=$(${SVCPROP} -cp \
				    ${service}/txt_record ${SMF_FMRI} \
				    2>/dev/null | \
				    ${CUT} -f 2 -s -d':')
				if [ "X${port}" != "X" -a  \
				    "${port}" != "${SMF_PORT}" ]; then
					mfest_dir=/var/ai/${port}/AI_data
				fi
			fi

			default_file=${mfest_dir}/default.xml
			echo "Looking for default file ${default_file}"
			if [ -f ${default_file} ] ; then
				echo "Default file found.  Upgrading service."
				# Default file found.  Install the new way.
				${INSTALLADM} add-manifest \
				    -n ${service_name} -d -f ${default_file}
				if [[ $? -eq 0 ]]; then
					${RM} ${default_file}
				else
					errors=y
					echo "Error running installadm."
				fi

			else
				errors=y
				echo "Unable to find default manifest for " \
				    "install service ${service_name}"
			fi
		fi

		if [ $errors = "n" ] ; then
			# Install version for this AI service
			${SVCCFG} -s ${SMF_FMRI} setprop ${service}/version = \
			    astring: \"${AI_SERVICE_VERSION}\"
			if [[ $? -ne 0 ]]; then
				echo "Error running svccfg to " \
				    "update service version."
				errors=y
			fi
		fi

		if [ $errors = "y" ] ; then
			echo "Upgrade of service " \
			    "${service_name} not completed."
		fi
	done

	if [ $do_refresh = "y" ] ; then
		echo "refreshing..."
		${SVCCFG} -s ${SMF_FMRI} refresh
	fi
}

case "$1" in
'start')
	# Code to execute on start

	# ensure that the default port is set
	if [ "X${SMF_PORT}" == "X" ]; then
		echo "The default port is not set for the service."
		exit ${SMF_EXIT_ERR_CONFIG}
	fi

        # Check if services need to be upgraded.
	upgrade_svc_vers_0_to_1

	# First run aimdns daemon to register mDNS records for every
	# service that is listed as enabled. 
	if [ -f ${AIMDNSD_PID} ] ; then
		# only if aimdns daemon is not running do we start another
		if [[ ! "$($PS -p $($CAT $AIMDNSD_PID) -o args=)" == \
		     ~(E)"$AIMDNSD\$" ]]; then
			$AIMDNSD &
		fi
	else
		# no PID file found start aimdns daemon
		$AIMDNSD &
	fi

	# Start up the apache web server using our http config file
	if [ -f ${AI_HTTPD_CONF} ] ; then
		setup_main_ports
		setup_compatibility_file
		${APACHE2} -f ${AI_HTTPD_CONF} -k start
		if [ $? -ne 0 ] ; then
			echo "Unable to start apache process"
			exit $SMF_EXIT_ERR_CONFIG
		fi	
	else
		echo "Unable to start apache process due to missing" \
				"config file ${AI_HTTPD_CONF}"
		exit $SMF_EXIT_ERR_CONFIG
	fi
	;;

'stop')
	# Code to execute on stop

	# stop aimdns daemon
	if [ -f ${AIMDNSD_PID} ] ; then
		${KILL} $($CAT $AIMDNSD_PID)
	fi

	# stop apache server
	if [ -f ${AI_HTTPD_CONF} ] ; then
		${APACHE2} -f ${AI_HTTPD_CONF} -k stop
		if [ $? -ne 0 ] ; then
			echo "Unable to stop apache process"
			exit $SMF_EXIT_ERR_CONFIG
		fi
		# wait for the apache servers to exit or the stop timeout is reached
		while [[ $($PGREP -f "${HTTPD} -f ${AI_HTTPD_CONF}") ]]; do
			sleep 1
		done
	else
		echo "Unable to stop apache process due to missing" \
				"config file ${AI_HTTPD_CONF}"
		exit $SMF_EXIT_ERR_CONFIG
	fi
	;;

refresh)
	# ensure that the default port  is set
	if [ "X${SMF_PORT}" == "X" ]; then
		echo "The default port is not set for the service."
		exit ${SMF_EXIT_ERR_CONFIG}
	fi

	# if the aimdns daemon is running, refresh it, otherwise start it up.
	if [ -f ${AIMDNSD_PID} ] ; then
		${KILL} -1 $($CAT $AIMDNSD_PID)
	else
		$AIMDNSD &
	fi

	setup_main_ports
	typeset -i ret1=$?
	setup_compatibility_file
	typeset -i ret2=$?
	if [[ $ret1 -eq 0 || $ret2 -eq 0 ]] ; then
		echo "Port configuration has changed, restarting webserver."
		${APACHE2} -f ${AI_HTTPD_CONF} -k restart
	else
		echo "Port configuration has not changed, not restarting" \
			"webserver."
	fi
	;;
	
*)
	echo "Usage: $0 { start | stop | refresh }"
	exit 1 
	;;


esac
exit 0
